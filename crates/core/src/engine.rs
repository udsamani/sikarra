use std::{pin::Pin, sync::Arc};

use futures::{Stream, StreamExt};
use tokio::{
    sync::{
        broadcast::{self, error::RecvError, Receiver, Sender},
        mpsc,
    },
    task::JoinSet,
};
use tracing::{error, event, info, warn};

use crate::{error::AppResult, runner::Runner};

/// A core processing trait that handles events and produces actions which can
/// be executed by the application.
#[async_trait::async_trait]
pub trait Engine<Event, Action>: Send + Sync {
    /// Get the unique identifier for the engine
    fn id(&self) -> &str;

    /// Engine proccesses an event according to the logic defined in the engine.
    /// It returns a vector of actions, which would ideally be executed by
    /// the application.
    async fn process_event(&mut self, event: Event) -> AppResult<Option<Action>>;
}

/// A specialzed stream type for event collectors in the application.
pub type CollectorStream<'a, Event> = Pin<Box<dyn Stream<Item = Event> + Send + 'a>>;

/// A trait for components that collect and stream events in the application.
///
/// The [`Collector`] trait defines pthe interface for any component capable of
/// collecting events of specific type and providing them as an asychronous
/// stream. Implementors of this trait act as event sources that other system
/// components can subscribe to.
#[async_trait::async_trait]
pub trait Collector<Event>: Send + Sync {
    /// Get the unique identifier for the collector
    fn name(&self) -> &str;

    /// Subscribes to a stream of events from this collector.
    async fn subscribe_event_stream(&mut self) -> AppResult<CollectorStream<'_, Event>>;

    /// Unsubscribe from the event stream of this collector
    async fn unsubscribe_event_stream(&mut self) -> AppResult<()>;
}

/// A trait that executes actions produced by the engine.
///
/// The [`Executor`] trait defines the interface for components responsible for
/// executing actions generated by the [`Engine`] after processing events. This
/// comonent represents the final step in the event processing pipeline.
#[async_trait::async_trait]
pub trait Executor<Action>: Send + Sync {
    /// Get the unique identifier for the executor
    fn id(&self) -> &str;

    /// Execute a vector of actions.
    async fn execute_actions(&mut self, actions: Vec<Action>) -> AppResult<()>;
}

/// A high level orchestrator that connects the event collection, processing,
/// and execution components of the application.
///
/// The [`EngineRunner`] struct implements the event processing pipeline by:
///     1. Collecting events from multiple [`Collector`]
///     2. Passing these events to the [`Engine`] components for processing
///     3. Forwarding the resulting actions to the [`Executor`] for execution
#[allow(unused)]
pub struct EngineRunner<Event, Action> {
    name: String,
    collectors: Vec<Box<dyn Collector<Event>>>,
    engine: Vec<Box<dyn Engine<Event, Action>>>,
    executors: Vec<Box<dyn Executor<Action>>>,
    event_channel_capacity: usize,
    action_channel_capacity: usize,
}

impl<Event, Action> EngineRunner<Event, Action> {
    /// Create a new instance of the EngineRunner with the specified name and
    /// channel capacities.
    pub fn new(
        name: String,
        event_channel_capacity: usize,
        action_channel_capacity: usize,
    ) -> Self {
        Self {
            name,
            collectors: Vec::new(),
            engine: Vec::new(),
            executors: Vec::new(),
            event_channel_capacity,
            action_channel_capacity,
        }
    }

    /// Add an event collector to the engine runner.
    pub fn add_collector(&mut self, collector: Box<dyn Collector<Event>>) {
        self.collectors.push(collector);
    }

    /// Add engine to the engine runner.
    pub fn add_engine(&mut self, engine: Box<dyn Engine<Event, Action>>) {
        self.engine.push(engine);
    }

    /// Add an executor the engine runner.
    pub fn add_executor(&mut self, executor: Box<dyn Executor<Action>>) {
        self.executors.push(executor);
    }
}

#[async_trait::async_trait]
impl<Event, Action, P> Runner<P> for EngineRunner<Event, Action>
where
    Event: Send + Clone + Sync + 'static,
    Action: Send + Clone + Sync + 'static,
    P: Send + Sync + 'static,
{
    fn name(&self) -> &str { &self.name }

    async fn run(
        self,
        parameters: P,
        shutdown: tokio_util::sync::CancellationToken,
    ) -> AppResult<()> {
        let (event_sender, event_receiver): (Sender<Event>, Receiver<Event>) =
            broadcast::channel(self.event_channel_capacity);
        let (action_sender, _): (Sender<Action>, _) =
            broadcast::channel(self.action_channel_capacity);

        let mut join_set = JoinSet::new();

        // Spawn the executors in separate tasks
        for mut executor in self.executors {
            let mut action_receiver = action_sender.subscribe();
            let executor_shutdown = shutdown.child_token();
            join_set.spawn(async move {
                info!("starting executor with id: {}", executor.id());
                loop {
                    tokio::select! {
                        action = action_receiver.recv() => match action {
                            Ok(action) => {
                                if let Err(e) = executor.execute_actions(vec![action]).await {
                                    error!("executor {} failed to execute actions: {}", executor.id(), e);
                                }
                            },
                            Err(RecvError::Closed) => {
                                info!("executor {} received closed channel, shutting down", executor.id());
                                break;
                            },
                            Err(RecvError::Lagged(_)) => {
                                warn!("executor {} lagged behind, some actions were dropped", executor.id());
                            }
                        },
                        _ = executor_shutdown.cancelled() => {
                            info!("executor {} received shutdown signal, exiting", executor.id());
                            break;
                        }
                    }
                }
            });
        }

        // Spawn engines in separate tasks
        for mut engine in self.engine {
            let mut event_receiver = event_sender.subscribe();
            let action_sender = action_sender.clone();
            let engine_shutdown = shutdown.child_token();
            join_set.spawn(async move {
                info!("starting engine with id: {}", engine.id());
                loop {
                    tokio::select! {
                        event = event_receiver.recv() => match event {
                            Ok(event) => {
                                if let Ok(Some(actions)) = engine.process_event(event).await {
                                    if let Err(e) = action_sender.send(actions) {
                                        error!("engine {} failed to send actions: {}", engine.id(), e);
                                    }
                                }
                            },
                            Err(RecvError::Closed) => {
                                info!("engine {} received closed channel, shutting down", engine.id());
                                break;
                            },
                            Err(RecvError::Lagged(_)) => {
                                warn!("engine {} lagged behind, some events were dropped", engine.id());
                            }
                        },
                        _ = engine_shutdown.cancelled() => {
                            info!("engine {} received shutdown signal, exiting", engine.id());
                            break;
                        }
                    }
                }

            });
        }

        /// Spawn the collectors in separate tasks.
        for mut collector in self.collectors {
            let event_sender = event_sender.clone();
            let collector_shutdown = shutdown.child_token();
            join_set.spawn(async move {
                let collector_name = collector.name().to_string();
                info!("starting collector with name: {}", collector_name);
                let mut event_stream = match collector.subscribe_event_stream().await {
                    Ok(stream) => stream,
                    Err(e) => {
                        error!("collector {} failed to subscribe to event stream: {}", collector_name, e);
                        return;
                    }
                };
                loop {
                    tokio::select! {
                        event = event_stream.next() => match event {
                            Some(event) => {
                                if let Err(e) = event_sender.send(event) {
                                    error!("collector {} failed to send event: {}", collector_name, e);
                                }
                            },
                            None => {
                                info!("collector {} received None from event stream, shutting down", collector_name);
                                break;
                            }
                        },
                        _ = collector_shutdown.cancelled() => {
                            drop(event_stream);
                            info!("collector {} received shutdown signal, exiting", collector_name);
                            match collector.unsubscribe_event_stream().await {
                                Ok(_) => info!("collector {} successfully unsubscribed from event stream", collector_name),
                                Err(e) => error!("collector {} failed to unsubscribe from event stream: {}", collector.name(), e),
                            }
                            break;
                        }
                    }
                }
            });
        }

        // Run until shutdowm, log all errors and return the last one
        let mut last_result = None;
        while let Some(result) = join_set.join_next().await {
            match &result {
                Ok(_) => continue,
                Err(e) => {
                    error!("task failed: {}", e);
                    last_result = Some(result);
                },
            }
        }
        last_result.unwrap_or(Ok(())).map_err(anyhow::Error::from)
    }
}
